using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using GhostServiceBuster.RegisterMethodsGenerator.Candidates;
using GhostServiceBuster.RegisterMethodsGenerator.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GhostServiceBuster;

[Generator]
public class RegisterMethods : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates =
            context.SyntaxProvider.ForAttributesWithMetadataNames(
                    [
                        "GhostServiceBuster.RegisterMethodsGenerator.GenerateRegisterMethodForAttribute",
                        "GhostServiceBuster.RegisterMethodsGenerator.GenerateRegisterMethodForFilterAttribute"
                    ],
                    static (node, _) => node is ClassDeclarationSyntax,
                    static (ctx, _) => GetCandidateOrNull((INamedTypeSymbol)ctx.TargetSymbol))
                .Collect();

        context.RegisterSourceOutput(candidates, GenerateSourceCode);
    }

    private static void GenerateSourceCode(
        SourceProductionContext spc, ImmutableArray<Candidate> candidates)
    {
        const string namespaceName = "GhostServiceBuster";
        const string className = "ServiceUsageVerifierExtensions";
        const string fileName = $"{className}.g.cs";

        if (candidates.Length is 0)
            return;

        var sb = new StringBuilder(
            $$"""
              // <auto-generated/>

              namespace {{namespaceName}};

              public static partial class {{className}}
              {
              """);

        AppendExtensionBodiesForCandidates(sb, candidates);

        sb.Append("}");

        spc.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void AppendExtensionBodiesForCandidates(
        StringBuilder stringBuilder, IReadOnlyList<Candidate> candidates)
    {
        candidates = [..candidates.OrderBy(c => c.Name, StringComparer.Ordinal)];
        var filterCandidates = candidates.OfType<ServiceInfoFilterCandidate>().ToList();
        var nonFilterCandidates = candidates.Except(filterCandidates).ToList();
        AppendExtensionBodiesForNonFilterCandidates(stringBuilder, nonFilterCandidates);
        AppendExtensionBodiesForFilterCandidates(stringBuilder, filterCandidates);
    }

    private static void AppendExtensionBodiesForNonFilterCandidates(
        StringBuilder stringBuilder, IReadOnlyList<Candidate> nonFilterCandidates)
    {
        if (nonFilterCandidates.Count is 0)
            return;
        
        stringBuilder.AppendLine(
            """
            
                extension<TServiceUsageVerifier>(TServiceUsageVerifier serviceUsageVerifier)
                    where TServiceUsageVerifier : IServiceUsageVerifierWithoutCachesMutable
                {
            """);

        AppendMethodsForCandidates(stringBuilder, false, nonFilterCandidates);

        stringBuilder.AppendLine("    }");
    }

    private static void AppendExtensionBodiesForFilterCandidates(
        StringBuilder stringBuilder, IReadOnlyList<ServiceInfoFilterCandidate> filterCandidates)
    {
        if (filterCandidates.Count is 0)
            return;
        
        stringBuilder.AppendLine(
            """
            
                extension(IServiceUsageVerifierWithoutCachesMutable serviceUsageVerifier)
                {
            """);

        AppendMethodsForCandidates(stringBuilder, false, filterCandidates);

        stringBuilder.AppendLine(
            """
                }

                extension(IServiceUsageVerifierWithCachedServicesMutable serviceUsageVerifier)
                {
            """);

        AppendMethodsForCandidates(stringBuilder, true, filterCandidates);

        stringBuilder.AppendLine("    }");
    }

    private static void AppendMethodsForCandidates(
        StringBuilder stringBuilder, bool forServiceUsageVerifierWithCachedServices,
        IReadOnlyList<Candidate> candidates)
    {
        foreach (var (candidate, isLast) in candidates.Select((candidate, index) =>
                     (candidate, index == candidates.Count - 1)))
        {
            stringBuilder.AppendLine(candidate.GetMethodCode(forServiceUsageVerifierWithCachedServices));

            if (!isLast)
                stringBuilder.AppendLine();
        }
    }

    private static Candidate GetCandidateOrNull(INamedTypeSymbol type)
    {
        var namespaceName = type.ContainingNamespace.ToDisplayString();
        var typeName = type.Name;
        var parameters = GetConstructorParameters(type);

        return type switch
        {
            _ when CheckIfCandidate(type, DependencyDetectorCandidate.InterfaceName) =>
                new DependencyDetectorCandidate(namespaceName, typeName, parameters),

            _ when GetCandidateInterface(type, ServiceInfoExtractorCandidate.InterfaceName) is { } i =>
                new ServiceInfoExtractorCandidate(i.TypeArguments[0].ToString(), namespaceName, typeName, parameters),

            _ when CheckIfCandidate(type, RootServiceInfoFilterCandidate.InterfaceName) =>
                new RootServiceInfoFilterCandidate(namespaceName, typeName, parameters),

            _ when CheckIfCandidate(type, ServiceInfoFilterCandidate.InterfaceName) =>
                new ServiceInfoFilterCandidate(GetFilterKind(type), namespaceName, typeName, parameters),

            _ => throw new InvalidOperationException($"Unsupported candidate type: {type}")
        };
    }

    private static bool CheckIfCandidate(INamedTypeSymbol type, string interfaceName) =>
        GetCandidateInterface(type, interfaceName) is not null;

    private static INamedTypeSymbol? GetCandidateInterface(INamedTypeSymbol type, string interfaceName) =>
        type.Interfaces.FirstOrDefault(i => GetFullName(i) == interfaceName);

    private static string GetFullName(INamedTypeSymbol i) => $"{i.ContainingNamespace}.{i.Name}";

    private static IReadOnlyList<Parameter> GetConstructorParameters(INamedTypeSymbol type) =>
        type.InstanceConstructors.SingleOrDefault()?.Parameters
            .Select(p => new Parameter(p.Type.ToDisplayString(), p.Name)).ToList() ?? [];

    private static FilterKind GetFilterKind(INamedTypeSymbol type)
    {
        var attribute = type.GetAttributes().FirstOrDefault(a =>
                            a.AttributeClass?.ToString() ==
                            "GhostServiceBuster.RegisterMethodsGenerator.GenerateRegisterMethodForFilterAttribute")
                        ?? throw new InvalidOperationException($"Attribute not found for {type}");

        return (FilterKind)(int)attribute.ConstructorArguments[0].Value!;
    }
}