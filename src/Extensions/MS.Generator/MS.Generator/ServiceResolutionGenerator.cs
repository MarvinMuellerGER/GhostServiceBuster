using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GhostServiceBuster.MS.Generator;

[Generator]
public class ServiceResolutionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assemblyName = context
            .CompilationProvider
            .Select((c, _) => c.AssemblyName);

        var invocations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is InvocationExpressionSyntax,
                static (ctx, _) => GetTypesResolvedByServiceProvider(ctx))
            .Where(static m => m is not null);

        var combined = assemblyName.Combine(invocations.Collect());

        context.RegisterSourceOutput(combined, GenerateSourceCode);
    }

    private static void GenerateSourceCode(
        SourceProductionContext spc,
        (string? AssemblyName, ImmutableArray<string?> TypesResolvedByServiceProvider) loadedData)
    {
        const string attributeNamespace = "GhostServiceBuster.MS.Generator";
        const string attributeName = "TypesResolvedByServiceProvider";
        const string attributeFullName = $"{attributeNamespace}.{attributeName}";
        const string fileName = $"{attributeName}.g.cs";

        var types = loadedData.TypesResolvedByServiceProvider.OfType<string>()
            .Distinct()
            .OrderBy(t => t)
            .ToList();

        if (types.Count is 0)
            return;

        var sb = new StringBuilder();
        sb.AppendLine($"""
                       // <auto-generated/>

                       [assembly: global::{attributeFullName}(
                       """);

        foreach (var (type, isLast) in types.Select((type, index) => (type, index == types.Count - 1)))
            sb.Append($"    typeof({type})").AppendLine(isLast ? null : ",");

        sb.AppendLine(")]");

        spc.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string? GetTypesResolvedByServiceProvider(GeneratorSyntaxContext ctx)
    {
        var invocation = (InvocationExpressionSyntax)ctx.Node;
        if (invocation.Expression is not MemberAccessExpressionSyntax member)
            return null;

        var methodName = member.Name.Identifier.Text;
        if (methodName is not ("GetServices" or "GetService" or "GetRequiredService" or "GetKeyedServices"
            or "GetKeyedService" or "GetRequiredKeyedService"))
            return null;

        if (ctx.SemanticModel.GetSymbolInfo(member).Symbol is not IMethodSymbol symbol)
            return null;

        if (!ImplementsIServiceProvider(symbol.ReceiverType as INamedTypeSymbol ?? symbol.ContainingType))
            return null;

        if (invocation.ArgumentList.Arguments.FirstOrDefault()?.Expression is TypeOfExpressionSyntax typeOfExpr)
            return ctx.SemanticModel.GetTypeInfo(typeOfExpr.Type).Type?.ToDisplayString();

        if (member.Name is not GenericNameSyntax generic)
            return null;

        var typeArg = generic.TypeArgumentList.Arguments.FirstOrDefault();
        return typeArg is null
            ? null
            : ctx.SemanticModel.GetTypeInfo(typeArg).Type?.ToDisplayString();
    }

    private static bool ImplementsIServiceProvider(INamedTypeSymbol? type)
    {
        const string serviceProviderFullName = "System.IServiceProvider";

        while (type is not null)
        {
            if (type.ToDisplayString() is serviceProviderFullName ||
                type.AllInterfaces.Any(i => i.ToDisplayString() is serviceProviderFullName))
                return true;

            type = type.BaseType;
        }

        return false;
    }
}