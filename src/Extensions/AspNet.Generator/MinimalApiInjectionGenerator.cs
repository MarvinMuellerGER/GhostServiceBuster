using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GhostServiceBuster.AspNet.Generator;

[Generator]
public class MinimalApiInjectionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var allInjectedTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is InvocationExpressionSyntax,
                static (ctx, _) => GetTypesInjectedIntoMinimalApi(ctx))
            .SelectMany(static (types, _) => types!)
            .Collect();

        context.RegisterSourceOutput(allInjectedTypes, GenerateSourceCode);
    }

    private static void GenerateSourceCode(
        SourceProductionContext spc, ImmutableArray<string> typesInjectedIntoMinimalApi)
    {
        const string attributeNamespace = "GhostServiceBuster.AspNet.Generator";
        const string attributeName = "TypesInjectedIntoMinimalApi";
        const string attributeFullName = $"{attributeNamespace}.{attributeName}";
        const string fileName = $"{attributeName}.g.cs";

        var types = typesInjectedIntoMinimalApi
            .OrderBy(t => t)
            .ToList();

        if (types.Count is 0)
            return;

        var sb = new StringBuilder();
        sb.AppendLine($"""
                       // <auto-generated/>

                       [assembly: global::{attributeFullName}(
                       """);

        foreach (var (type, isLast) in types.Select((type, index) => (type, index == types.Count - 1)))
            sb.Append($"    typeof({type})").AppendLine(isLast ? null : ",");

        sb.AppendLine(")]");

        spc.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static IEnumerable<string> GetTypesInjectedIntoMinimalApi(GeneratorSyntaxContext ctx)
    {
        var invocation = (InvocationExpressionSyntax)ctx.Node;

        if (ctx.SemanticModel.GetSymbolInfo(invocation).Symbol is not IMethodSymbol symbol ||
            invocation.ArgumentList.Arguments.Count is 0 ||
            !IsMinimalApiMapMethod(symbol))
            return [];

        var handlerArg = invocation.ArgumentList.Arguments.Last();

        return ExtractInjectedTypes(handlerArg.Expression, ctx.SemanticModel);
    }

    private static bool IsMinimalApiMapMethod(IMethodSymbol method) =>
        method.Name.StartsWith("Map")
        && method.ContainingType.ToDisplayString().Contains("EndpointRouteBuilderExtensions");

    private static IEnumerable<string> ExtractInjectedTypes(ExpressionSyntax expr, SemanticModel model) =>
        expr switch
        {
            ParenthesizedLambdaExpressionSyntax parenLambda => parenLambda.ParameterList.Parameters
                .Select(p => model.GetDeclaredSymbol(p) as IParameterSymbol)
                .Where(ps => ps is not null && IsInjected(ps)).Select(ps => ps!.Type.ToDisplayString()),

            SimpleLambdaExpressionSyntax simpleLambda =>
                model.GetDeclaredSymbol(simpleLambda.Parameter) is IParameterSymbol ps && IsInjected(ps)
                    ? [ps.Type.ToDisplayString()]
                    : [],

            MemberAccessExpressionSyntax memberAccess =>
                GetInjectedTypesFromMethodGroup(memberAccess, model),

            IdentifierNameSyntax identifierName =>
                GetInjectedTypesFromMethodGroup(identifierName, model),

            _ => []
        };

    private static IEnumerable<string> GetInjectedTypesFromMethodGroup(ExpressionSyntax methodGroupExpr,
        SemanticModel model)
    {
        var symbolInfo = model.GetSymbolInfo(methodGroupExpr);

        var methods =
            symbolInfo.Symbol is IMethodSymbol single
                ? [single]
                : symbolInfo.CandidateSymbols.OfType<IMethodSymbol>();

        return methods
            .SelectMany(m => m.Parameters)
            .Where(IsInjected)
            .Select(p => p.Type.ToDisplayString())
            .Distinct();
    }

    private static bool IsInjected(IParameterSymbol p)
    {
        if (p.GetAttributes().Any(a => a.AttributeClass?.Name.StartsWith("From") is true))
            return false;

        if (p.Type.SpecialType is not SpecialType.None)
            return false;

        return p.Type.ToDisplayString() is
            not ("Microsoft.AspNetCore.Http.HttpContext" or
            "Microsoft.AspNetCore.Http.HttpRequest" or
            "Microsoft.AspNetCore.Http.HttpResponse" or
            "System.Threading.CancellationToken" or
            "System.Security.Claims.ClaimsPrincipal");
    }
}